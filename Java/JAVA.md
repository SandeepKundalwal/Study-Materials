# Java

### **1 Is Java Platform Independent. If yes, then how?**
Java uses **javac compiler** which compiles the program to form a bytecode or `.class` file. This file is platform independent but needs a **JVM (Java Virtual Machine)** for further execution of the bytecode. 


### **2 What is JVM?**  
JVM stands for Java Virtual Machine. It is a java interpreter. It is reponsible for loadin, verifying, and executing the bytecode created in Java. JVM is platform dependent  because it is a program that runs on a specific OS. Different systems have different architectures, so the JVM needs to be tailored for each one.

![alt text](image.png)

### **3 Explain JVM Architecture.**  
JVM acts as a runtime engine to run Java applications. It is the one that acutally calls the main method present in a Java code. JVM is a part of **JRE (Java Reuntime Environment)**.

When we compile a `.java` file, `.class` file (contains byte-code) with the same class names present in `.java` file are generated by the Java compiler. This `.class` file goes into various steps when we run it.

![alt text](image-1.png)  

- **Class Loader Subsytem:** It is mainly reponsible for three activities:
    - **Loading**: The Class loader reads the `.class` file, generate the corresponding binary data and save it in the method area
    - **Linking**: Performs verification, preparation, and (optionally) resolution.
        - **Verification**: It ensures the correctness of the `.class` file.
        - **Preparation**: JVM allocates memory for class static variables and intializing the memory to default values.
        - **Resolution**: It is the process of replacing symbolic references from the type with direct references. It is done by searching into the method area to locate the referenced entity.
    - **Initilaization**: In this phase, all static variables are assigned with their values defined in the code and static block(if any). This is executed from top to bottom in a class and from parent to child in the class hierarchy.

- **JVM Memory:**
    - **Method Area**: In the method area, all class level information like class name, immediate parent class name, methods and variables information etc. are stored, including static variables. There is only one method area per JVM, and it is a shared resource.
    - **Heap Area**: Information of all objects is stored in the heap area. there is also only one Heap Area per JVM. It is a shared resource.
    - **Stack Area**: For every thread, JVM creates one run-time stack which is stored here. Every block of this stack is called Activation record/stack frame which stores method class. All local variables of that method are stored in their corresponding frame. After a thread terminates, its run-time stack will be destroyed by JVM. It is not a shared resource.
    - **PC Registers**: Stores address of current execution instruction of a thread. Each thread has a seperate PC registers.
    - **Native Method Stack**: For every thread, a seperate native stack is created. It stores native method information.

- **Execution Engine:**  It executes the `.class` It reads the byte-code line by line, uses data and infromation present in various memory area and executes instructions. It can be classified into three parts:
    - **Interpreter**: it interprets the bytecode line by line and then executes. The disadvantage here is that when one method is called multiple times, every time interpretation is required.
    - **Just-In-Time compiler**: It is used to increase the efficieny of an interpreter. It compiles the entire bytecode and changes it to native code so whenever the interpreter sees repeated method calls, JIT provides direct native code for that part so re-interpretation is not required, this efficiency is improved.
    - **Garbage Collector**: It destroyes un-referenced objects.

- **Java Native Interface:** It is an interface that interacts with the Native Method Libraries and provdes the native libraries(C, C++) required for the execution. It enables JVM to call C/C++ libraries and to be called by by C/C++ libraries which may be specific to hardware.

* **Native Method Libraries:** It is a collection of the Native Libraries(C, C++) which are required by the Execution Engine.

### **4 Explain JIT**  
![alt text](image-2.png)

JIT stand for **Just-In-Time** compiler.It is a part of JRE. It is used for better performance of the Java applications during run-time. The uses of JIT is mentioned in step by step process below:
    - Source code is compiled with **javac** compiler to form bytecode.
    - Bytecode is further passed on to JVM.
    - JIT is a part of JVM. It is reposible for compiling bytecode into native machine code at run-time.
    - The JIT Compiler is enabled throughout, while it gets activated when a method is invoked. For a compiled method, the JVM directly calls the compiled code, instead of interpreting it.
    - As JVM calls the compiled code, this increases the performance and speed of the execution.

### **5 What is Native Method?** 


### **6 Gargabe Collector**

### **7 Explain JRE**


